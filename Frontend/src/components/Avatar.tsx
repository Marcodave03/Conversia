/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.3 public/models/64f1a714fe61576b46f27ca2.glb -o src/components/Avatar.tsx -k -r public
*/

import { useAnimations, useGLTF } from "@react-three/drei";
import { useFrame, GroupProps } from "@react-three/fiber";
import { button, useControls } from "leva";
import { useEffect, useRef, useState } from "react";
import * as THREE from "three";
import { GLTF } from "three-stdlib";

// Type definitions for GLTF result
type GLTFResult = GLTF & {
  nodes: Record<string, THREE.Object3D>;
  materials: Record<string, THREE.Material>;
};

// Props definition for Avatar component
interface AvatarProps extends GroupProps {
    customProperty?: string; // Example custom property
  }

  interface SkinnedMeshWithMorphTargets extends THREE.SkinnedMesh {
    morphTargetDictionary?: Record<string, number>;
    morphTargetInfluences?: number[];
}
  

// Facial expressions data structure
const facialExpressions: Record<string, Record<string, number>> = { /* facial expressions data */ };

// Track setup mode state
let setupMode = false;

export function Avatar(props: AvatarProps) {
  const { nodes, scene } = useGLTF(
    "/models/67d03bfc1a20f78f15a414bc.glb"
  ) as GLTFResult;

  const { animations } = useGLTF("/models/animations.glb") as GLTFResult;

  const group = useRef<THREE.Group>(null);
  const { actions } = useAnimations(animations, group);

  const [animation, setAnimation] = useState<string>(
    animations.find((a) => a.name === "Idle") ? "Idle" : animations[0].name
  );

  useEffect(() => {
    if (actions && actions[animation]) {
      actions[animation]?.reset().fadeIn(actions[animation]?.isRunning() ? 0.5 : 0).play();
    }
    return () => {
        if (actions?.[animation]) {
          actions[animation].fadeOut(0.5);
        }
      };      
  }, [actions, animation]);

  const lerpMorphTarget = (target: string, value: number, speed = 0.1) => {
    if (!scene) return;

    scene.traverse((child) => {
        if (child instanceof THREE.SkinnedMesh) {
            const skinnedMesh = child as SkinnedMeshWithMorphTargets;
            if (skinnedMesh.morphTargetDictionary && skinnedMesh.morphTargetInfluences) {
                const index = skinnedMesh.morphTargetDictionary[target];
                if (index !== undefined) {
                    skinnedMesh.morphTargetInfluences[index] = THREE.MathUtils.lerp(
                        skinnedMesh.morphTargetInfluences[index],
                        value,
                        speed
                    );
                }
            }
        }
    });
};

  const [blink, setBlink] = useState<boolean>(false);
  const [winkLeft, setWinkLeft] = useState<boolean>(false);
  const [winkRight, setWinkRight] = useState<boolean>(false);
  const [facialExpression, setFacialExpression] = useState<string>("");

  useFrame(() => {
    const eyeLeft = nodes.EyeLeft as SkinnedMeshWithMorphTargets | undefined;

    if (!setupMode && eyeLeft?.morphTargetDictionary) {
        Object.keys(eyeLeft.morphTargetDictionary).forEach((key) => {
            const mapping = facialExpressions[facialExpression];
            if (key === "eyeBlinkLeft" || key === "eyeBlinkRight") return;

            if (mapping && mapping[key]) {
                lerpMorphTarget(key, mapping[key], 0.1);
            } else {
                lerpMorphTarget(key, 0, 0.1);
            }
        });

        lerpMorphTarget("eyeBlinkLeft", blink || winkLeft ? 1 : 0, 0.5);
        lerpMorphTarget("eyeBlinkRight", blink || winkRight ? 1 : 0, 0.5);
    }
});


  useControls("FacialExpressions", {
    winkLeft: button(() => {
      setWinkLeft(true);
      setTimeout(() => setWinkLeft(false), 300);
    }),
    winkRight: button(() => {
      setWinkRight(true);
      setTimeout(() => setWinkRight(false), 300);
    }),
    animation: {
      value: animation,
      options: animations.map((a) => a.name),
      onChange: (value: string) => setAnimation(value),
    },
    facialExpression: {
      options: Object.keys(facialExpressions),
      onChange: (value: string) => setFacialExpression(value),
    },
    enableSetupMode: button(() => {
      setupMode = true;
    }),
    disableSetupMode: button(() => {
      setupMode = false;
    }),
  });

  useEffect(() => {
    let blinkTimeout: NodeJS.Timeout;

    const nextBlink = () => {
      blinkTimeout = setTimeout(() => {
        setBlink(true);
        setTimeout(() => {
          setBlink(false);
          nextBlink();
        }, 200);
      }, THREE.MathUtils.randInt(1000, 5000));
    };

    nextBlink();

    return () => clearTimeout(blinkTimeout);
  }, []);

  return (
    <group {...props} dispose={null} ref={group}>
      <primitive object={nodes.Hips} />
      {/* Remaining skinned mesh components */}
    </group>
  );
}

// Preload models
useGLTF.preload("/models/67d03bfc1a20f78f15a414bc.glb");
useGLTF.preload("/models/animations.glb");
